package pdfGenerator

import (
	"fmt"
	"os"
	"os/exec"

	"github.com/baptistemehat/go-leadsheet/core/song/model"
	"github.com/baptistemehat/go-leadsheet/core/song/parser"
)

// Generation status
type Status uint8

const (
	StatusNotStarted Status = iota
	StatusInProgress Status = iota
	StatusDone       Status = iota
	StatusError      Status = iota
)

func (s Status) String() string {
	switch s {
	case StatusNotStarted:
		return "not started"
	case StatusInProgress:
		return "in progress"
	case StatusDone:
		return "done"
	case StatusError:
		return "error"
	default:
		return ""
	}
}

// Builder stores parser and formatter to use for text processing
type Builder struct {
	Parser    parser.Parser
	Formatter model.Formatter
}

// PdfGenerator
type PdfGenerator struct {
	status     Status
	outputFile string
	builder    Builder
}

func NewPdfGenerator(builder Builder) (*PdfGenerator, error) {
	p := &PdfGenerator{
		status:     StatusNotStarted,
		outputFile: "latex/tmp/out/main.pdf",
		builder:    builder,
	}
	return p, nil
}

// Status returns pdf generation status
func (pg PdfGenerator) Status() Status {
	return pg.status
}

// Output returns path to the generated pdf file
func (pg PdfGenerator) Output() string {
	return pg.outputFile
}

// txt2tex "transpiles" input raw text files into leadsheet LateX files
// This function calls script txt2tex.sh
func (pg PdfGenerator) txt2tex(source string) error {
	cmd := exec.Command("./pdfGenerator/scripts/txt2tex.sh", source)

	out, err := cmd.Output()

	if err != nil {
		fmt.Println(string(out))
		return err
	}

	return nil
}

// tex2pdf generates pdf file from the files generated by txt2tex.sh
// This function calls script generate-pdf.sh
func (pg PdfGenerator) tex2pdf() error {
	// TODO : add output file as argument to have coherence between pdfGenerator.Output and shell scripts
	cmd := exec.Command("./pdfGenerator/scripts/generate-pdf.sh")

	out, err := cmd.Output()

	if err != nil {
		fmt.Println(string(out))
		return err
	}

	return nil
}

// WriteStringToFile writes string buffer to a file
func WriteStringToFile(buffer, fileName string) error {
	file, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer file.Close()

	file.WriteString(buffer)

	return nil
}

// GeneratePdfFromBuffer generates pdf from a string buffer
func (pg *PdfGenerator) GeneratePdfFromBuffer(buffer string) error {

	pg.status = StatusInProgress

	// Write input to file
	if err := WriteStringToFile(buffer, "latex/tmp/songs/leadsheet.txt"); err != nil {
		pg.status = StatusError
		return err
	}

	// Parse input
	song, err := pg.builder.Parser.Parse(buffer)
	if err != nil {
		pg.status = StatusError
		return err
	}

	// Format song
	formattedSong, err := song.Format(pg.builder.Formatter)
	if err != nil {
		pg.status = StatusError
		return err
	}

	// Write formatted song
	if err := WriteStringToFile(formattedSong, "latex/tmp/songs/leadsheet.tex"); err != nil {
		pg.status = StatusError
		return err
	}
	defer os.Remove("latex/tmp/songs/leadsheet.tex")

	// Compile latex
	if err := pg.tex2pdf(); err != nil {
		pg.status = StatusError
		return err
	}

	pg.status = StatusDone
	return nil
}

// GeneratePdfFromBuffer_WithScripts generates a pdf leadsheet from a string buffer, only using scripts
func (pg *PdfGenerator) GeneratePdfFromBuffer_WithScripts(buffer string) error {

	sourceFile := "latex/tmp/leadsheet.txt.tmp"

	f, err := os.Create(sourceFile)
	if err != nil {
		return err
	}

	defer os.Remove(sourceFile)

	f.WriteString(buffer)
	f.Close()

	return pg.GeneratePdfFromFile(sourceFile)
}

// GeneratePdfFromFile generates a pdf song file from a raw text source file
func (pg *PdfGenerator) GeneratePdfFromFile(source string) error {

	pg.status = StatusInProgress

	err := pg.txt2tex(source)
	if err != nil {
		pg.status = StatusError
		return err
	}

	err = pg.tex2pdf()
	if err != nil {
		pg.status = StatusError
		return err
	}

	pg.status = StatusDone
	return nil
}
